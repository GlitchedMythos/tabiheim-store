-- TimescaleDB Performance Optimization Migration
-- Creates continuous aggregate for latest product prices
-- This migration should be run AFTER the index migration generated by drizzle-kit

-- Drop the continuous aggregate if it exists (for idempotency)
DROP MATERIALIZED VIEW IF EXISTS latest_product_prices CASCADE;

-- Create continuous aggregate view for latest prices
-- This pre-aggregates the most recent price for each product subtype
-- Uses TimescaleDB's last() function to get the most recent value
CREATE MATERIALIZED VIEW latest_product_prices
WITH (timescaledb.continuous) AS
SELECT
  product_subtype_id,
  last(low_price, recorded_at) as low_price,
  last(mid_price, recorded_at) as mid_price,
  last(high_price, recorded_at) as high_price,
  last(market_price, recorded_at) as market_price,
  last(direct_low_price, recorded_at) as direct_low_price,
  max(recorded_at) as recorded_at,
  time_bucket(INTERVAL '1 day', recorded_at) AS bucket
FROM product_price
GROUP BY product_subtype_id, bucket
WITH NO DATA;

-- Create index on the continuous aggregate for fast lookups
CREATE INDEX IF NOT EXISTS idx_latest_prices_subtype_id
ON latest_product_prices (product_subtype_id);

-- Add refresh policy to automatically update the continuous aggregate
-- Refreshes data from 1 month ago up to 1 hour ago, runs every hour
SELECT add_continuous_aggregate_policy('latest_product_prices',
  start_offset => INTERVAL '1 month',
  end_offset => INTERVAL '1 hour',
  schedule_interval => INTERVAL '1 hour');

-- Initial refresh to populate the view
CALL refresh_continuous_aggregate('latest_product_prices', NULL, NULL);

-- Create a helper view for easy querying of latest prices (without time buckets)
CREATE OR REPLACE VIEW v_latest_product_prices AS
SELECT DISTINCT ON (product_subtype_id)
  product_subtype_id,
  low_price,
  mid_price,
  high_price,
  market_price,
  direct_low_price,
  recorded_at
FROM latest_product_prices
ORDER BY product_subtype_id, recorded_at DESC;

